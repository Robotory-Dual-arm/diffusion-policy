"use strict";(self.webpackChunkk3d=self.webpackChunkk3d||[]).push([[808],{8808:(t,e,n)=>{n.r(e),n.d(e,{AVERAGE:()=>i,CENTER:()=>o,CONTAINED:()=>u,ExtendedTriangle:()=>V,FloatVertexAttributeTexture:()=>re,INTERSECTED:()=>c,IntVertexAttributeTexture:()=>ne,MeshBVH:()=>Ft,MeshBVHUniformStruct:()=>oe,MeshBVHVisualizer:()=>kt,NOT_INTERSECTED:()=>a,OrientedBox:()=>F,SAH:()=>s,StaticGeometryGenerator:()=>Te,UIntVertexAttributeTexture:()=>ee,VertexAttributeTexture:()=>te,acceleratedRaycast:()=>$t,computeBoundsTree:()=>Jt,disposeBoundsTree:()=>Kt,estimateMemoryInBytes:()=>qt,getBVHExtremes:()=>Lt,getJSONStructure:()=>Xt,getTriangleHitPointInfo:()=>j,shaderIntersectFunction:()=>se,shaderStructs:()=>ie,validateBounds:()=>Wt});var r=n(3488);const o=0,i=1,s=2,a=0,c=1,u=2,l=1.25,d=32,f=65535,h=Math.pow(2,-24);class p{constructor(){}}function y(t,e,n){return n.min.x=e[t],n.min.y=e[t+1],n.min.z=e[t+2],n.max.x=e[t+3],n.max.y=e[t+4],n.max.z=e[t+5],n}function m(t){let e=-1,n=-1/0;for(let r=0;r<3;r++){const o=t[r+3]-t[r];o>n&&(n=o,e=r)}return e}function g(t,e){e.set(t)}function x(t,e,n){let r,o;for(let i=0;i<3;i++){const s=i+3;r=t[i],o=e[i],n[i]=r<o?r:o,r=t[s],o=e[s],n[s]=r>o?r:o}}function b(t,e,n){for(let r=0;r<3;r++){const o=e[t+2*r],i=e[t+2*r+1],s=o-i,a=o+i;s<n[r]&&(n[r]=s),a>n[r+3]&&(n[r+3]=a)}}function w(t){const e=t[3]-t[0],n=t[4]-t[1],r=t[5]-t[2];return 2*(e*n+n*r+r*e)}function v(t,e,n,r,o=null){let i=1/0,s=1/0,a=1/0,c=-1/0,u=-1/0,l=-1/0,d=1/0,f=1/0,h=1/0,p=-1/0,y=-1/0,m=-1/0;const g=null!==o;for(let r=6*e,o=6*(e+n);r<o;r+=6){const e=t[r+0],n=t[r+1],o=e-n,x=e+n;o<i&&(i=o),x>c&&(c=x),g&&e<d&&(d=e),g&&e>p&&(p=e);const b=t[r+2],w=t[r+3],v=b-w,B=b+w;v<s&&(s=v),B>u&&(u=B),g&&b<f&&(f=b),g&&b>y&&(y=b);const T=t[r+4],A=t[r+5],M=T-A,P=T+A;M<a&&(a=M),P>l&&(l=P),g&&T<h&&(h=T),g&&T>m&&(m=T)}r[0]=i,r[1]=s,r[2]=a,r[3]=c,r[4]=u,r[5]=l,g&&(o[0]=d,o[1]=f,o[2]=h,o[3]=p,o[4]=y,o[5]=m)}const B=(t,e)=>t.candidate-e.candidate,T=new Array(32).fill().map((()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}))),A=new Float32Array(6);class M{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,r=-1/0;for(let o=0,i=t.length;o<i;o++){const i=t[o][e];n=i<n?i:n,r=i>r?i:r}this.min=n,this.max=r}setFromPoints(t,e){let n=1/0,r=-1/0;for(let o=0,i=e.length;o<i;o++){const i=e[o],s=t.dot(i);n=s<n?s:n,r=s>r?s:r}this.min=n,this.max=r}isSeparated(t){return this.min>t.max||t.min>this.max}}M.prototype.setFromBox=function(){const t=new r.Vector3;return function(e,n){const r=n.min,o=n.max;let i=1/0,s=-1/0;for(let n=0;n<=1;n++)for(let a=0;a<=1;a++)for(let c=0;c<=1;c++){t.x=r.x*n+o.x*(1-n),t.y=r.y*a+o.y*(1-a),t.z=r.z*c+o.z*(1-c);const u=e.dot(t);i=Math.min(u,i),s=Math.max(u,s)}this.min=i,this.max=s}}(),new M;const P=function(){const t=new r.Vector3,e=new r.Vector3,n=new r.Vector3;return function(r,o,i){const s=r.start,a=t,c=o.start,u=e;n.subVectors(s,c),t.subVectors(r.end,o.start),e.subVectors(o.end,o.start);const l=n.dot(u),d=u.dot(a),f=u.dot(u),h=n.dot(a),p=a.dot(a)*f-d*d;let y,m;y=0!==p?(l*d-h*f)/p:0,m=(l+y*d)/f,i.x=y,i.y=m}}(),I=function(){const t=new r.Vector2,e=new r.Vector3,n=new r.Vector3;return function(r,o,i,s){P(r,o,t);let a=t.x,c=t.y;if(a>=0&&a<=1&&c>=0&&c<=1)return r.at(a,i),void o.at(c,s);if(a>=0&&a<=1)return c<0?o.at(0,s):o.at(1,s),void r.closestPointToPoint(s,!0,i);if(c>=0&&c<=1)return a<0?r.at(0,i):r.at(1,i),void o.closestPointToPoint(i,!0,s);{let t,u;t=a<0?r.start:r.end,u=c<0?o.start:o.end;const l=e,d=n;return r.closestPointToPoint(u,!0,e),o.closestPointToPoint(t,!0,n),l.distanceToSquared(u)<=d.distanceToSquared(t)?(i.copy(l),void s.copy(u)):(i.copy(t),void s.copy(d))}}}(),S=function(){const t=new r.Vector3,e=new r.Vector3,n=new r.Plane,o=new r.Line3;return function(r,i){const{radius:s,center:a}=r,{a:c,b:u,c:l}=i;if(o.start=c,o.end=u,o.closestPointToPoint(a,!0,t).distanceTo(a)<=s)return!0;if(o.start=c,o.end=l,o.closestPointToPoint(a,!0,t).distanceTo(a)<=s)return!0;if(o.start=u,o.end=l,o.closestPointToPoint(a,!0,t).distanceTo(a)<=s)return!0;const d=i.getPlane(n);if(Math.abs(d.distanceToPoint(a))<=s){const t=d.projectPoint(a,e);if(i.containsPoint(t))return!0}return!1}}();class V extends r.Triangle{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map((()=>new r.Vector3)),this.satBounds=new Array(4).fill().map((()=>new M)),this.points=[this.a,this.b,this.c],this.sphere=new r.Sphere,this.plane=new r.Plane,this.needsUpdate=!1}intersectsSphere(t){return S(t,this)}update(){const t=this.a,e=this.b,n=this.c,r=this.points,o=this.satAxes,i=this.satBounds,s=o[0],a=i[0];this.getNormal(s),a.setFromPoints(s,r);const c=o[1],u=i[1];c.subVectors(t,e),u.setFromPoints(c,r);const l=o[2],d=i[2];l.subVectors(e,n),d.setFromPoints(l,r);const f=o[3],h=i[3];f.subVectors(n,t),h.setFromPoints(f,r),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(s,t),this.needsUpdate=!1}}V.prototype.closestPointToSegment=function(){const t=new r.Vector3,e=new r.Vector3,n=new r.Line3;return function(r,o=null,i=null){const{start:s,end:a}=r,c=this.points;let u,l=1/0;for(let s=0;s<3;s++){const a=(s+1)%3;n.start.copy(c[s]),n.end.copy(c[a]),I(n,r,t,e),u=t.distanceToSquared(e),u<l&&(l=u,o&&o.copy(t),i&&i.copy(e))}return this.closestPointToPoint(s,t),u=s.distanceToSquared(t),u<l&&(l=u,o&&o.copy(t),i&&i.copy(s)),this.closestPointToPoint(a,t),u=a.distanceToSquared(t),u<l&&(l=u,o&&o.copy(t),i&&i.copy(a)),Math.sqrt(l)}}(),V.prototype.intersectsTriangle=function(){const t=new V,e=new Array(3),n=new Array(3),o=new M,i=new M,s=new r.Vector3,a=new r.Vector3,c=new r.Vector3,u=new r.Vector3,l=new r.Line3,d=new r.Line3,f=new r.Line3;return function(r,h=null){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(t.copy(r),t.update(),r=t);const p=this.plane,y=r.plane;if(Math.abs(p.normal.dot(y.normal))>1-1e-10){const t=this.satBounds,a=this.satAxes;n[0]=r.a,n[1]=r.b,n[2]=r.c;for(let e=0;e<4;e++){const r=t[e],i=a[e];if(o.setFromPoints(i,n),r.isSeparated(o))return!1}const c=r.satBounds,u=r.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let t=0;t<4;t++){const n=c[t],r=u[t];if(o.setFromPoints(r,e),n.isSeparated(o))return!1}for(let t=0;t<4;t++){const r=a[t];for(let t=0;t<4;t++){const a=u[t];if(s.crossVectors(r,a),o.setFromPoints(s,e),i.setFromPoints(s,n),o.isSeparated(i))return!1}}return h&&(console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),h.start.set(0,0,0),h.end.set(0,0,0)),!0}{const t=this.points;let e=!1,n=0;for(let r=0;r<3;r++){const o=t[r],i=t[(r+1)%3];if(l.start.copy(o),l.end.copy(i),l.delta(a),0===y.normal.dot(a)&&0===y.distanceToPoint(l.start)){d.copy(l),n=2;break}if(y.intersectLine(l,e?d.start:d.end)){if(n++,e)break;e=!0}}if(2!==n)return!1;const o=r.points;let i=!1,s=0;for(let t=0;t<3;t++){const e=o[t],n=o[(t+1)%3];if(l.start.copy(e),l.end.copy(n),l.delta(c),0===p.normal.dot(c)&&0===p.distanceToPoint(l.start)){f.copy(l),s=2;break}if(p.intersectLine(l,i?f.start:f.end)){if(s++,i)break;i=!0}}if(2!==s)return!1;if(d.delta(a),f.delta(c),a.dot(c)<0){let t=f.start;f.start=f.end,f.end=t}const m=d.start.dot(a),g=d.end.dot(a),x=f.start.dot(a),b=f.end.dot(a);return(m===b||x===g||g<x!=m<b)&&(h&&(u.subVectors(d.start,f.start),u.dot(a)>0?h.start.copy(d.start):h.start.copy(f.start),u.subVectors(d.end,f.end),u.dot(a)<0?h.end.copy(d.end):h.end.copy(f.end)),!0)}}}(),V.prototype.distanceToPoint=function(){const t=new r.Vector3;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),V.prototype.distanceToTriangle=function(){const t=new r.Vector3,e=new r.Vector3,n=["a","b","c"],o=new r.Line3,i=new r.Line3;return function(r,s=null,a=null){const c=s||a?o:null;if(this.intersectsTriangle(r,c))return(s||a)&&(s&&c.getCenter(s),a&&c.getCenter(a)),0;let u=1/0;for(let e=0;e<3;e++){let o;const i=n[e],c=r[i];this.closestPointToPoint(c,t),o=c.distanceToSquared(t),o<u&&(u=o,s&&s.copy(t),a&&a.copy(c));const l=this[i];r.closestPointToPoint(l,t),o=l.distanceToSquared(t),o<u&&(u=o,s&&s.copy(l),a&&a.copy(t))}for(let c=0;c<3;c++){const l=n[c],d=n[(c+1)%3];o.set(this[l],this[d]);for(let c=0;c<3;c++){const l=n[c],d=n[(c+1)%3];i.set(r[l],r[d]),I(o,i,t,e);const f=t.distanceToSquared(e);f<u&&(u=f,s&&s.copy(t),a&&a.copy(e))}}return Math.sqrt(u)}}();class F extends r.Box3{constructor(...t){super(...t),this.isOrientedBox=!0,this.matrix=new r.Matrix4,this.invMatrix=new r.Matrix4,this.points=new Array(8).fill().map((()=>new r.Vector3)),this.satAxes=new Array(3).fill().map((()=>new r.Vector3)),this.satBounds=new Array(3).fill().map((()=>new M)),this.alignedSatBounds=new Array(3).fill().map((()=>new M)),this.needsUpdate=!1}set(t,e,n){super.set(t,e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){super.copy(t),this.matrix.copy(t.matrix),this.needsUpdate=!0}}F.prototype.update=function(){const t=this.matrix,e=this.min,n=this.max,r=this.points;for(let o=0;o<=1;o++)for(let i=0;i<=1;i++)for(let s=0;s<=1;s++){const a=r[1*o|2*i|4*s];a.x=o?n.x:e.x,a.y=i?n.y:e.y,a.z=s?n.z:e.z,a.applyMatrix4(t)}const o=this.satBounds,i=this.satAxes,s=r[0];for(let t=0;t<3;t++){const e=i[t],n=o[t],a=r[1<<t];e.subVectors(s,a),n.setFromPoints(e,r)}const a=this.alignedSatBounds;a[0].setFromPointsField(r,"x"),a[1].setFromPointsField(r,"y"),a[2].setFromPointsField(r,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1},F.prototype.intersectsBox=function(){const t=new M;return function(e){this.needsUpdate&&this.update();const n=e.min,r=e.max,o=this.satBounds,i=this.satAxes,s=this.alignedSatBounds;if(t.min=n.x,t.max=r.x,s[0].isSeparated(t))return!1;if(t.min=n.y,t.max=r.y,s[1].isSeparated(t))return!1;if(t.min=n.z,t.max=r.z,s[2].isSeparated(t))return!1;for(let n=0;n<3;n++){const r=i[n],s=o[n];if(t.setFromBox(r,e),s.isSeparated(t))return!1}return!0}}(),F.prototype.intersectsTriangle=function(){const t=new V,e=new Array(3),n=new M,o=new M,i=new r.Vector3;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(t.copy(r),t.update(),r=t);const s=this.satBounds,a=this.satAxes;e[0]=r.a,e[1]=r.b,e[2]=r.c;for(let t=0;t<3;t++){const r=s[t],o=a[t];if(n.setFromPoints(o,e),r.isSeparated(n))return!1}const c=r.satBounds,u=r.satAxes,l=this.points;for(let t=0;t<3;t++){const e=c[t],r=u[t];if(n.setFromPoints(r,l),e.isSeparated(n))return!1}for(let t=0;t<3;t++){const r=a[t];for(let t=0;t<4;t++){const s=u[t];if(i.crossVectors(r,s),n.setFromPoints(i,e),o.setFromPoints(i,l),n.isSeparated(o))return!1}}return!0}}(),F.prototype.closestPointToPoint=function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e},F.prototype.distanceToPoint=function(){const t=new r.Vector3;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),F.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map((()=>new r.Line3)),n=new Array(12).fill().map((()=>new r.Line3)),o=new r.Vector3,i=new r.Vector3;return function(r,s=0,a=null,c=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(a||c)&&(r.getCenter(i),this.closestPointToPoint(i,o),r.closestPointToPoint(o,i),a&&a.copy(o),c&&c.copy(i)),0;const u=s*s,l=r.min,d=r.max,f=this.points;let h=1/0;for(let t=0;t<8;t++){const e=f[t];i.copy(e).clamp(l,d);const n=e.distanceToSquared(i);if(n<h&&(h=n,a&&a.copy(e),c&&c.copy(i),n<u))return Math.sqrt(n)}let p=0;for(let r=0;r<3;r++)for(let o=0;o<=1;o++)for(let i=0;i<=1;i++){const s=(r+1)%3,a=(r+2)%3,c=1<<r|o<<s|i<<a,u=f[o<<s|i<<a],h=f[c];e[p].set(u,h);const y=t[r],m=t[s],g=t[a],x=n[p],b=x.start,w=x.end;b[y]=l[y],b[m]=o?l[m]:d[m],b[g]=i?l[g]:d[m],w[y]=d[y],w[m]=o?l[m]:d[m],w[g]=i?l[g]:d[m],p++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let n=0;n<=1;n++){i.x=t?d.x:l.x,i.y=e?d.y:l.y,i.z=n?d.z:l.z,this.closestPointToPoint(i,o);const r=i.distanceToSquared(o);if(r<h&&(h=r,a&&a.copy(o),c&&c.copy(i),r<u))return Math.sqrt(r)}for(let t=0;t<12;t++){const r=e[t];for(let t=0;t<12;t++){const e=n[t];I(r,e,o,i);const s=o.distanceToSquared(i);if(s<h&&(h=s,a&&a.copy(o),c&&c.copy(i),s<u))return Math.sqrt(s)}}return Math.sqrt(h)}}();const D=new r.Vector3,E=new r.Vector3,U=new r.Vector3,z=new r.Vector2,N=new r.Vector2,_=new r.Vector2,G=new r.Vector3;function k(t,e,n,o,i){const s=3*o,a=t.index.getX(s),c=t.index.getX(s+1),u=t.index.getX(s+2),l=function(t,e,n,o,i,s,a){D.fromBufferAttribute(e,o),E.fromBufferAttribute(e,i),U.fromBufferAttribute(e,s);const c=function(t,e,n,o,i,s){let a;return a=s===r.BackSide?t.intersectTriangle(o,n,e,!0,i):t.intersectTriangle(e,n,o,s!==r.DoubleSide,i),null===a?null:{distance:t.origin.distanceTo(i),point:i.clone()}}(t,D,E,U,G,a);if(c){n&&(z.fromBufferAttribute(n,o),N.fromBufferAttribute(n,i),_.fromBufferAttribute(n,s),c.uv=r.Triangle.getUV(G,D,E,U,z,N,_,new r.Vector2));const t={a:o,b:i,c:s,normal:new r.Vector3,materialIndex:0};r.Triangle.getNormal(D,E,U,t.normal),c.face=t,c.faceIndex=o}return c}(n,t.attributes.position,t.attributes.uv,a,c,u,e);return l?(l.faceIndex=o,i&&i.push(l),l):null}function R(t,e,n){return null===t?null:(t.point.applyMatrix4(e.matrixWorld),t.distance=t.point.distanceTo(n.ray.origin),t.object=e,t.distance<n.near||t.distance>n.far?null:t)}function H(t,e,n,r){const o=t.a,i=t.b,s=t.c;let a=e,c=e+1,u=e+2;n&&(a=n.getX(e),c=n.getX(e+1),u=n.getX(e+2)),o.x=r.getX(a),o.y=r.getY(a),o.z=r.getZ(a),i.x=r.getX(c),i.y=r.getY(c),i.z=r.getZ(c),s.x=r.getX(u),s.y=r.getY(u),s.z=r.getZ(u)}function C(t,e,n,r,o,i,s){const a=n.index,c=n.attributes.position;for(let n=t,u=e+t;n<u;n++)if(H(s,3*n,a,c),s.needsUpdate=!0,r(s,n,o,i))return!0;return!1}const O=new r.Vector3,L=new r.Vector3,q=new r.Vector3,W=new r.Vector2,X=new r.Vector2,Y=new r.Vector2;function j(t,e,n,o){const i=e.getIndex().array,s=e.getAttribute("position"),a=e.getAttribute("uv"),c=i[3*n],u=i[3*n+1],l=i[3*n+2];O.fromBufferAttribute(s,c),L.fromBufferAttribute(s,u),q.fromBufferAttribute(s,l);let d=0;const f=e.groups,h=3*n;for(let t=0,e=f.length;t<e;t++){const e=f[t],{start:n,count:r}=e;if(h>=n&&h<n+r){d=e.materialIndex;break}}let p=null;return a&&(W.fromBufferAttribute(a,c),X.fromBufferAttribute(a,u),Y.fromBufferAttribute(a,l),p=o&&o.uv?o.uv:new r.Vector2,r.Triangle.getUV(t,O,L,q,W,X,Y,p)),o?(o.face||(o.face={}),o.face.a=c,o.face.b=u,o.face.c=l,o.face.materialIndex=d,o.face.normal||(o.face.normal=new r.Vector3),r.Triangle.getNormal(O,L,q,o.face.normal),o.uv||(o.uv=new r.Vector2),o.uv.copy(p),o):{face:{a:c,b:u,c:l,materialIndex:d,normal:r.Triangle.getNormal(O,L,q,new r.Vector3)},uv:p}}class Z{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}function $(t,e){return 65535===e[t+15]}function J(t,e){return e[t+6]}function K(t,e){return e[t+14]}function Q(t){return t+8}function tt(t,e){return e[t+6]}function et(t,e){return e[t+7]}const nt=new r.Box3,rt=new r.Vector3,ot=["x","y","z"];function it(t,e,n,r,o){let i=2*t,s=ft,a=ht,c=pt;if($(i,a))!function(t,e,n,r,o,i){for(let s=r,a=r+o;s<a;s++)k(t,e,n,s,i)}(e,n,r,J(t,c),K(i,a),o);else{const i=Q(t);ut(i,s,r,rt)&&it(i,e,n,r,o);const a=tt(t,c);ut(a,s,r,rt)&&it(a,e,n,r,o)}}function st(t,e,n,r){let o=2*t,i=ft,s=ht,a=pt;if($(o,s))return function(t,e,n,r,o){let i=1/0,s=null;for(let a=r,c=r+o;a<c;a++){const r=k(t,e,n,a);r&&r.distance<i&&(s=r,i=r.distance)}return s}(e,n,r,J(t,a),K(o,s));{const o=et(t,a),s=ot[o],c=r.direction[s]>=0;let u,l;c?(u=Q(t),l=tt(t,a)):(u=tt(t,a),l=Q(t));const d=ut(u,i,r,rt)?st(u,e,n,r):null;if(d){const t=d.point[s];if(c?t<=i[l+o]:t>=i[l+o+3])return d}const f=ut(l,i,r,rt)?st(l,e,n,r):null;return d&&f?d.distance<=f.distance?d:f:d||f||null}}const at=function(){let t,e;const n=[],o=new Z((()=>new r.Box3));return function(...r){t=o.getPrimitive(),e=o.getPrimitive(),n.push(t,e);const s=i(...r);o.releasePrimitive(t),o.releasePrimitive(e),n.pop(),n.pop();const a=n.length;return a>0&&(e=n[a-1],t=n[a-2]),s};function i(n,r,o,s,a=null,c=0,l=0){function d(t){let e=2*t,n=ht,r=pt;for(;!$(e,n);)e=2*(t=Q(t));return J(t,r)}function f(t){let e=2*t,n=ht,r=pt;for(;!$(e,n);)e=2*(t=tt(t,r));return J(t,r)+K(e,n)}let h=2*n,p=ft,m=ht,g=pt;if($(h,m)){const e=J(n,g),r=K(h,m);return y(n,p,t),s(e,r,!1,l,c+n,t)}{const h=Q(n),x=tt(n,g);let b,w,v,B,T=h,A=x;if(a&&(v=t,B=e,y(T,p,v),y(A,p,B),b=a(v),w=a(B),w<b)){T=x,A=h;const t=b;b=w,w=t,v=B}v||(v=t,y(T,p,v));const M=o(v,$(2*T,m),b,l+1,c+T);let P;if(M===u){const t=d(T);P=s(t,f(T)-t,!0,l+1,c+T,v)}else P=M&&i(T,r,o,s,a,c,l+1);if(P)return!0;B=e,y(A,p,B);const I=o(B,$(2*A,m),w,l+1,c+A);let S;if(I===u){const t=d(A);S=s(t,f(A)-t,!0,l+1,c+A,B)}else S=I&&i(A,r,o,s,a,c,l+1);return!!S}}}(),ct=function(){const t=new V,e=new V,n=new r.Matrix4,o=new F,i=new F;return function r(s,a,c,u,l=null){let d=2*s,f=ft,h=ht,p=pt;if(null===l&&(c.boundingBox||c.computeBoundingBox(),o.set(c.boundingBox.min,c.boundingBox.max,u),l=o),!$(d,h)){const t=s+8,e=p[s+6];return y(t,f,nt),l.intersectsBox(nt)&&r(t,a,c,u,l)?!0:(y(e,f,nt),!(!l.intersectsBox(nt)||!r(e,a,c,u,l)))}{const r=a,o=r.index,l=r.attributes.position,m=c.index,g=c.attributes.position,x=J(s,p),b=K(d,h);if(n.copy(u).invert(),c.boundsTree)return y(s,f,i),i.matrix.copy(n),i.needsUpdate=!0,c.boundsTree.shapecast({intersectsBounds:t=>i.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(u),t.b.applyMatrix4(u),t.c.applyMatrix4(u),t.needsUpdate=!0;for(let n=3*x,r=3*(b+x);n<r;n+=3)if(H(e,n,o,l),e.needsUpdate=!0,t.intersectsTriangle(e))return!0;return!1}});for(let r=3*x,i=b+3*x;r<i;r+=3){H(t,r,o,l),t.a.applyMatrix4(n),t.b.applyMatrix4(n),t.c.applyMatrix4(n),t.needsUpdate=!0;for(let n=0,r=m.count;n<r;n+=3)if(H(e,n,m,g),e.needsUpdate=!0,t.intersectsTriangle(e))return!0}}}}();function ut(t,e,n,r){return y(t,e,nt),n.intersectBox(nt,r)}const lt=[];let dt,ft,ht,pt;function yt(t){dt&&lt.push(dt),dt=t,ft=new Float32Array(t),ht=new Uint16Array(t),pt=new Uint32Array(t)}function mt(){dt=null,ft=null,ht=null,pt=null,lt.length&&yt(lt.pop())}const gt=Symbol("skip tree generation"),xt=new r.Box3,bt=new r.Box3,wt=new r.Matrix4,vt=new F,Bt=new F,Tt=new r.Vector3,At=new r.Vector3,Mt=new r.Vector3,Pt=new r.Vector3,It=new r.Vector3,St=new r.Box3,Vt=new Z((()=>new V));class Ft{static serialize(t,e={}){if(e.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),Ft.serialize(arguments[0],{cloneBuffers:void 0===arguments[2]||arguments[2]});e={cloneBuffers:!0,...e};const n=t.geometry,r=t._roots,o=n.getIndex();let i;return i=e.cloneBuffers?{roots:r.map((t=>t.slice())),index:o.array.slice()}:{roots:r,index:o.array},i}static deserialize(t,e,n={}){if("boolean"==typeof n)return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),Ft.deserialize(arguments[0],arguments[1],{setIndex:void 0===arguments[2]||arguments[2]});n={setIndex:!0,...n};const{index:o,roots:i}=t,s=new Ft(e,{...n,[gt]:!0});if(s._roots=i,n.setIndex){const n=e.getIndex();if(null===n){const n=new r.BufferAttribute(t.index,1,!1);e.setIndex(n)}else n.array!==o&&(n.array.set(o),n.needsUpdate=!0)}return s}constructor(t,e={}){if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if((e=Object.assign({strategy:o,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[gt]:!1},e)).useSharedArrayBuffer&&"undefined"==typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,e[gt]||(this._roots=function(t,e){const n=function(t,e){function n(t){S&&S(t/V)}function a(e,r,c,h=null,S=0){if(!F&&S>=y&&(F=!0,M&&(console.warn(`MeshBVH: Max depth of ${y} reached when generating BVH. Consider increasing maxDepth.`),console.warn(t))),c<=P||S>=y)return n(r+c),e.offset=r,e.count=c,e;const V=function(t,e,n,r,a,c){let u=-1,d=0;if(c===o)u=m(e),-1!==u&&(d=(e[u]+e[u+3])/2);else if(c===i)u=m(t),-1!==u&&(d=function(t,e,n,r){let o=0;for(let i=e,s=e+n;i<s;i++)o+=t[6*i+2*r];return o/n}(n,r,a,u));else if(c===s){const o=w(t);let i=l*a;const s=6*r,c=6*(r+a);for(let t=0;t<3;t++){const r=e[t],f=(e[t+3]-r)/32;if(a<8){const e=[...T];e.length=a;let r=0;for(let o=s;o<c;o+=6,r++){const i=e[r];i.candidate=n[o+2*t],i.count=0;const{bounds:s,leftCacheBounds:a,rightCacheBounds:c}=i;for(let t=0;t<3;t++)c[t]=1/0,c[t+3]=-1/0,a[t]=1/0,a[t+3]=-1/0,s[t]=1/0,s[t+3]=-1/0;b(o,n,s)}e.sort(B);let f=a;for(let t=0;t<f;t++){const n=e[t];for(;t+1<f&&e[t+1].candidate===n.candidate;)e.splice(t+1,1),f--}for(let r=s;r<c;r+=6){const o=n[r+2*t];for(let t=0;t<f;t++){const i=e[t];o>=i.candidate?b(r,n,i.rightCacheBounds):(b(r,n,i.leftCacheBounds),i.count++)}}for(let n=0;n<f;n++){const r=e[n],s=r.count,c=a-r.count,f=r.leftCacheBounds,h=r.rightCacheBounds;let p=0;0!==s&&(p=w(f)/o);let y=0;0!==c&&(y=w(h)/o);const m=1+l*(p*s+y*c);m<i&&(u=t,i=m,d=r.candidate)}}else{for(let t=0;t<32;t++){const e=T[t];e.count=0,e.candidate=r+f+t*f;const n=e.bounds;for(let t=0;t<3;t++)n[t]=1/0,n[t+3]=-1/0}for(let e=s;e<c;e+=6){let o=~~((n[e+2*t]-r)/f);o>=32&&(o=31);const i=T[o];i.count++,b(e,n,i.bounds)}const e=T[31];g(e.bounds,e.rightCacheBounds);for(let t=30;t>=0;t--){const e=T[t],n=T[t+1];x(e.bounds,n.rightCacheBounds,e.rightCacheBounds)}let h=0;for(let e=0;e<31;e++){const n=T[e],r=n.count,s=n.bounds,c=T[e+1].rightCacheBounds;0!==r&&(0===h?g(s,A):x(s,A,A)),h+=r;let f=0,p=0;0!==h&&(f=w(A)/o);const y=a-h;0!==y&&(p=w(c)/o);const m=1+l*(f*h+p*y);m<i&&(u=t,i=m,d=n.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${c} used.`);return{axis:u,pos:d}}(e.boundingData,h,d,r,c,I);if(-1===V.axis)return n(r+c),e.offset=r,e.count=c,e;const D=function(t,e,n,r,o){let i=n,s=n+r-1;const a=o.pos,c=2*o.axis;for(;;){for(;i<=s&&e[6*i+c]<a;)i++;for(;i<=s&&e[6*s+c]>=a;)s--;if(!(i<s))return i;for(let n=0;n<3;n++){let r=t[3*i+n];t[3*i+n]=t[3*s+n],t[3*s+n]=r;let o=e[6*i+2*n+0];e[6*i+2*n+0]=e[6*s+2*n+0],e[6*s+2*n+0]=o;let a=e[6*i+2*n+1];e[6*i+2*n+1]=e[6*s+2*n+1],e[6*s+2*n+1]=a}i++,s--}}(f,d,r,c,V);if(D===r||D===r+c)n(r+c),e.offset=r,e.count=c;else{e.splitAxis=V.axis;const t=new p,n=r,o=D-r;e.left=t,t.boundingData=new Float32Array(6),v(d,n,o,t.boundingData,u),a(t,n,o,u,S+1);const i=new p,s=D,l=c-o;e.right=i,i.boundingData=new Float32Array(6),v(d,s,l,i.boundingData,u),a(i,s,l,u,S+1)}return e}!function(t,e){if(!t.index){const n=t.attributes.position.count,o=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let i;i=n>65535?new Uint32Array(new o(4*n)):new Uint16Array(new o(2*n)),t.setIndex(new r.BufferAttribute(i,1));for(let t=0;t<n;t++)i[t]=t}}(t,e);const c=new Float32Array(6),u=new Float32Array(6),d=function(t,e){const n=t.attributes.position,r=n.array,o=t.index.array,i=o.length/3,s=new Float32Array(6*i),a=n.offset||0;let c=3;n.isInterleavedBufferAttribute&&(c=n.data.stride);for(let t=0;t<i;t++){const n=3*t,i=6*t,u=o[n+0]*c+a,l=o[n+1]*c+a,d=o[n+2]*c+a;for(let t=0;t<3;t++){const n=r[u+t],o=r[l+t],a=r[d+t];let c=n;o<c&&(c=o),a<c&&(c=a);let f=n;o>f&&(f=o),a>f&&(f=a);const p=(f-c)/2,y=2*t;s[i+y+0]=c+p,s[i+y+1]=p+(Math.abs(c)+p)*h,c<e[t]&&(e[t]=c),f>e[t+3]&&(e[t+3]=f)}}return s}(t,c),f=t.index.array,y=e.maxDepth,M=e.verbose,P=e.maxLeafTris,I=e.strategy,S=e.onProgress,V=t.index.count/3;let F=!1;const D=[],E=function(t){if(!t.groups||!t.groups.length)return[{offset:0,count:t.index.count/3}];const e=[],n=new Set;for(const e of t.groups)n.add(e.start),n.add(e.start+e.count);const r=Array.from(n.values()).sort(((t,e)=>t-e));for(let t=0;t<r.length-1;t++){const n=r[t],o=r[t+1];e.push({offset:n/3,count:(o-n)/3})}return e}(t);if(1===E.length){const t=E[0],e=new p;e.boundingData=c,function(t,e,n,r){let o=1/0,i=1/0,s=1/0,a=-1/0,c=-1/0,u=-1/0;for(let r=6*e,l=6*(e+n);r<l;r+=6){const e=t[r+0];e<o&&(o=e),e>a&&(a=e);const n=t[r+2];n<i&&(i=n),n>c&&(c=n);const l=t[r+4];l<s&&(s=l),l>u&&(u=l)}r[0]=o,r[1]=i,r[2]=s,r[3]=a,r[4]=c,r[5]=u}(d,t.offset,t.count,u),a(e,t.offset,t.count,u),D.push(e)}else for(let t of E){const e=new p;e.boundingData=new Float32Array(6),v(d,t.offset,t.count,e.boundingData,u),a(e,t.offset,t.count,u),D.push(e)}return D}(t,e);let a,c,u;const y=[],M=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let t=0;t<n.length;t++){const e=n[t];let r=P(e);const o=new M(d*r);a=new Float32Array(o),c=new Uint32Array(o),u=new Uint16Array(o),I(0,e),y.push(o)}return y;function P(t){return t.count?1:1+P(t.left)+P(t.right)}function I(t,e){const n=t/4,r=t/2,o=!!e.count,i=e.boundingData;for(let t=0;t<6;t++)a[n+t]=i[t];if(o){const o=e.offset,i=e.count;return c[n+6]=o,u[r+14]=i,u[r+15]=f,t+d}{const r=e.left,o=e.right,i=e.splitAxis;let s;if(s=I(t+d,r),s/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return c[n+6]=s/4,s=I(s,o),c[n+7]=i,s}}}(t,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new r.Box3))),this.geometry=t}refit(t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=this.geometry,n=e.index.array,r=e.attributes.position,o=r.array,i=r.offset||0;let s,a,c,u,l=3;r.isInterleavedBufferAttribute&&(l=r.data.stride);let d=0;const h=this._roots;for(let t=0,e=h.length;t<e;t++)s=h[t],a=new Uint32Array(s),c=new Uint16Array(s),u=new Float32Array(s),p(0,d),d+=s.byteLength;function p(e,r,s=!1){const d=2*e;if(c[d+15]===f){const t=a[e+6];let r=1/0,s=1/0,f=1/0,h=-1/0,p=-1/0,y=-1/0;for(let e=3*t,a=3*(t+c[d+14]);e<a;e++){const t=n[e]*l+i,a=o[t+0],c=o[t+1],u=o[t+2];a<r&&(r=a),a>h&&(h=a),c<s&&(s=c),c>p&&(p=c),u<f&&(f=u),u>y&&(y=u)}return(u[e+0]!==r||u[e+1]!==s||u[e+2]!==f||u[e+3]!==h||u[e+4]!==p||u[e+5]!==y)&&(u[e+0]=r,u[e+1]=s,u[e+2]=f,u[e+3]=h,u[e+4]=p,u[e+5]=y,!0)}{const n=e+8,o=a[e+6],i=n+r,c=o+r;let l=s,d=!1,f=!1;t?l||(d=t.has(i),f=t.has(c),l=!d&&!f):(d=!0,f=!0);const h=l||f;let y=!1;(l||d)&&(y=p(n,r,l));let m=!1;h&&(m=p(o,r,l));const g=y||m;if(g)for(let t=0;t<3;t++){const r=n+t,i=o+t,s=u[r],a=u[r+3],c=u[i],l=u[i+3];u[e+t]=s<c?s:c,u[e+t+3]=a>l?a:l}return g}}}traverse(t,e=0){const n=this._roots[e],r=new Uint32Array(n),o=new Uint16Array(n);!function e(i,s=0){const a=2*i,c=o[a+15]===f;if(c){const e=r[i+6],u=o[a+14];t(s,c,new Float32Array(n,4*i,6),e,u)}else{const o=i+8,a=r[i+6],u=r[i+7];t(s,c,new Float32Array(n,4*i,6),u)||(e(o,s+1),e(a,s+1))}}(0)}raycast(t,e=r.FrontSide){const n=this._roots,o=this.geometry,i=[],s=e.isMaterial,a=Array.isArray(e),c=o.groups,u=s?e.side:e;for(let r=0,s=n.length;r<s;r++){const s=a?e[c[r].materialIndex].side:u,l=i.length;if(yt(n[r]),it(0,o,s,t,i),mt(),a){const t=c[r].materialIndex;for(let e=l,n=i.length;e<n;e++)i[e].face.materialIndex=t}}return i}raycastFirst(t,e=r.FrontSide){const n=this._roots,o=this.geometry,i=e.isMaterial,s=Array.isArray(e);let a=null;const c=o.groups,u=i?e.side:e;for(let r=0,i=n.length;r<i;r++){const i=s?e[c[r].materialIndex].side:u;yt(n[r]);const l=st(0,o,i,t);mt(),null!=l&&(null==a||l.distance<a.distance)&&(a=l,s&&(l.face.materialIndex=c[r].materialIndex))}return a}intersectsGeometry(t,e){const n=this.geometry;let r=!1;for(const o of this._roots)if(yt(o),r=ct(0,n,t,e),mt(),r)break;return r}shapecast(t,e,n){const r=this.geometry;if(t instanceof Function){if(e){const t=e;e=(e,n,r,o)=>{const i=3*n;return t(e,i,i+1,i+2,r,o)}}t={boundsTraverseOrder:n,intersectsBounds:t,intersectsTriangle:e,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const o=Vt.getPrimitive();let{boundsTraverseOrder:i,intersectsBounds:s,intersectsRange:a,intersectsTriangle:c}=t;if(a&&c){const t=a;a=(e,n,i,s,a)=>!!t(e,n,i,s,a)||C(e,n,r,c,i,s,o)}else a||(a=c?(t,e,n,i)=>C(t,e,r,c,n,i,o):(t,e,n)=>n);let u=!1,l=0;for(const t of this._roots){if(yt(t),u=at(0,r,s,a,i,l),mt(),u)break;l+=t.byteLength}return Vt.releasePrimitive(o),u}bvhcast(t,e,n){let{intersectsRanges:r,intersectsTriangles:o}=n;const i=this.geometry.index,s=this.geometry.attributes.position,a=t.geometry.index,c=t.geometry.attributes.position;wt.copy(e).invert();const u=Vt.getPrimitive(),l=Vt.getPrimitive();if(o){function f(t,n,r,d,f,h,p,y){for(let m=r,g=r+d;m<g;m++){H(l,3*m,a,c),l.a.applyMatrix4(e),l.b.applyMatrix4(e),l.c.applyMatrix4(e),l.needsUpdate=!0;for(let e=t,r=t+n;e<r;e++)if(H(u,3*e,i,s),u.needsUpdate=!0,o(u,l,e,m,f,h,p,y))return!0}return!1}if(r){const h=r;r=function(t,e,n,r,o,i,s,a){return!!h(t,e,n,r,o,i,s,a)||f(t,e,n,r,o,i,s,a)}}else r=f}this.getBoundingBox(bt),bt.applyMatrix4(e);const d=this.shapecast({intersectsBounds:t=>bt.intersectsBox(t),intersectsRange:(e,n,o,i,s,a)=>(xt.copy(a),xt.applyMatrix4(wt),t.shapecast({intersectsBounds:t=>xt.intersectsBox(t),intersectsRange:(t,o,a,c,u)=>r(e,n,t,o,i,s,c,u)}))});return Vt.releasePrimitive(u),Vt.releasePrimitive(l),d}intersectsBox(t,e){return vt.set(t.min,t.max,e),vt.needsUpdate=!0,this.shapecast({intersectsBounds:t=>vt.intersectsBox(t),intersectsTriangle:t=>vt.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},r={},o=0,i=1/0){t.boundingBox||t.computeBoundingBox(),vt.set(t.boundingBox.min,t.boundingBox.max,e),vt.needsUpdate=!0;const s=this.geometry,a=s.attributes.position,c=s.index,u=t.attributes.position,l=t.index,d=Vt.getPrimitive(),f=Vt.getPrimitive();let h=At,p=Mt,y=null,m=null;r&&(y=Pt,m=It);let g=1/0,x=null,b=null;return wt.copy(e).invert(),Bt.matrix.copy(wt),this.shapecast({boundsTraverseOrder:t=>vt.distanceToBox(t),intersectsBounds:(t,e,n)=>n<g&&n<i&&(e&&(Bt.min.copy(t.min),Bt.max.copy(t.max),Bt.needsUpdate=!0),!0),intersectsRange:(n,r)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:t=>Bt.distanceToBox(t),intersectsBounds:(t,e,n)=>n<g&&n<i,intersectsRange:(t,i)=>{for(let s=3*t,w=3*(t+i);s<w;s+=3){H(f,s,l,u),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let t=3*n,e=3*(n+r);t<e;t+=3){H(d,t,c,a),d.needsUpdate=!0;const e=d.distanceToTriangle(f,h,y);if(e<g&&(p.copy(h),m&&m.copy(y),g=e,x=t/3,b=s/3),e<o)return!0}}}});for(let t=0,i=l?l.count:u.count;t<i;t+=3){H(f,t,l,u),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let e=3*n,i=3*(n+r);e<i;e+=3){H(d,e,c,a),d.needsUpdate=!0;const n=d.distanceToTriangle(f,h,y);if(n<g&&(p.copy(h),m&&m.copy(y),g=n,x=e/3,b=t/3),n<o)return!0}}}}),Vt.releasePrimitive(d),Vt.releasePrimitive(f),g===1/0?null:(n.point?n.point.copy(p):n.point=p.clone(),n.distance=g,n.faceIndex=x,r&&(r.point?r.point.copy(m):r.point=m.clone(),r.point.applyMatrix4(wt),p.applyMatrix4(wt),r.distance=p.sub(r.point).length(),r.faceIndex=b),n)}closestPointToPoint(t,e={},n=0,r=1/0){const o=n*n,i=r*r;let s=1/0,a=null;if(this.shapecast({boundsTraverseOrder:e=>(Tt.copy(t).clamp(e.min,e.max),Tt.distanceToSquared(t)),intersectsBounds:(t,e,n)=>n<s&&n<i,intersectsTriangle:(e,n)=>{e.closestPointToPoint(t,Tt);const r=t.distanceToSquared(Tt);return r<s&&(At.copy(Tt),s=r,a=n),r<o}}),s===1/0)return null;const c=Math.sqrt(s);return e.point?e.point.copy(At):e.point=At.clone(),e.distance=c,e.faceIndex=a,e}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach((e=>{y(0,new Float32Array(e),St),t.union(St)})),t}}const Dt=Ft.prototype.raycast;Ft.prototype.raycast=function(...t){if(t[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycast" has changed. See docs for new signature.');const[e,n,r,o]=t;return Dt.call(this,r,e.material).forEach((t=>{(t=R(t,e,n))&&o.push(t)})),o}return Dt.apply(this,t)};const Et=Ft.prototype.raycastFirst;Ft.prototype.raycastFirst=function(...t){if(t[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycastFirst" has changed. See docs for new signature.');const[e,n,r]=t;return R(Et.call(this,r,e.material),e,n)}return Et.apply(this,t)};const Ut=Ft.prototype.closestPointToPoint;Ft.prototype.closestPointToPoint=function(...t){if(t[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "closestPointToPoint" has changed. See docs for new signature.'),t.unshift();const e=t[1],n={};return t[1]=n,Ut.apply(this,t),e&&e.copy(n.point),n.distance}return Ut.apply(this,t)};const zt=Ft.prototype.closestPointToGeometry;Ft.prototype.closestPointToGeometry=function(...t){const e=t[2],n=t[3];if(e&&e.isVector3||n&&n.isVector3){console.warn('MeshBVH: The function signature and results frame for "closestPointToGeometry" has changed. See docs for new signature.');const r={},o={},i=t[1];return t[2]=r,t[3]=o,zt.apply(this,t),e&&e.copy(r.point),n&&n.copy(o.point).applyMatrix4(i),r.distance}return zt.apply(this,t)};const Nt=Ft.prototype.refit;Ft.prototype.refit=function(...t){const e=t[0],n=t[1];if(n&&(n instanceof Set||Array.isArray(n))){console.warn('MeshBVH: The function signature for "refit" has changed. See docs for new signature.');const t=new Set;n.forEach((e=>t.add(e))),e&&e.forEach((e=>t.add(e))),Nt.call(this,t)}else Nt.apply(this,t)},["intersectsGeometry","shapecast","intersectsBox","intersectsSphere"].forEach((t=>{const e=Ft.prototype[t];Ft.prototype[t]=function(...n){return(null===n[0]||n[0].isMesh)&&(n.shift(),console.warn(`MeshBVH: The function signature for "${t}" has changed and no longer takes Mesh. See docs for new signature.`)),e.apply(this,n)}}));const _t=new r.Box3;class Gt extends r.Object3D{get isMesh(){return!this.displayEdges}get isLineSegments(){return this.displayEdges}get isLine(){return this.displayEdges}constructor(t,e,n=10,o=0){super(),this.material=e,this.geometry=new r.BufferGeometry,this.name="MeshBVHRootVisualizer",this.depth=n,this.displayParents=!1,this.mesh=t,this.displayEdges=!0,this._group=o}raycast(){}update(){const t=this.geometry,e=this.mesh.geometry.boundsTree,n=this._group;if(t.dispose(),this.visible=!1,e){const o=this.depth-1,i=this.displayParents;let s=0;e.traverse(((t,e)=>{if(t===o||e)return s++,!0;i&&s++}),n);let a=0;const c=new Float32Array(24*s);let u,l;e.traverse(((t,e,n)=>{const r=t===o||e;if(r||i){y(0,n,_t);const{min:t,max:e}=_t;for(let n=-1;n<=1;n+=2){const r=n<0?t.x:e.x;for(let n=-1;n<=1;n+=2){const o=n<0?t.y:e.y;for(let n=-1;n<=1;n+=2){const i=n<0?t.z:e.z;c[a+0]=r,c[a+1]=o,c[a+2]=i,a+=3}}}return r}}),n),l=this.displayEdges?new Uint8Array([0,4,1,5,2,6,3,7,0,2,1,3,4,6,5,7,0,1,2,3,4,5,6,7]):new Uint8Array([0,1,2,2,1,3,4,6,5,6,7,5,1,4,5,0,4,1,2,3,6,3,7,6,0,2,4,2,6,4,1,5,3,3,5,7]),u=c.length>65535?new Uint32Array(l.length*s):new Uint16Array(l.length*s);const d=l.length;for(let t=0;t<s;t++){const e=8*t,n=t*d;for(let t=0;t<d;t++)u[n+t]=e+l[t]}t.setIndex(new r.BufferAttribute(u,1,!1)),t.setAttribute("position",new r.BufferAttribute(c,3,!1)),this.visible=!0}}}class kt extends r.Group{get color(){return this.edgeMaterial.color}get opacity(){return this.edgeMaterial.opacity}set opacity(t){this.edgeMaterial.opacity=t,this.meshMaterial.opacity=t}constructor(t,e=10){super(),this.name="MeshBVHVisualizer",this.depth=e,this.mesh=t,this.displayParents=!1,this.displayEdges=!0,this._roots=[];const n=new r.LineBasicMaterial({color:65416,transparent:!0,opacity:.3,depthWrite:!1}),o=new r.MeshBasicMaterial({color:65416,transparent:!0,opacity:.3,depthWrite:!1});o.color=n.color,this.edgeMaterial=n,this.meshMaterial=o,this.update()}update(){const t=this.mesh.geometry.boundsTree,e=t?t._roots.length:0;for(;this._roots.length>e;)this._roots.pop();for(let t=0;t<e;t++){if(t>=this._roots.length){const e=new Gt(this.mesh,this.edgeMaterial,this.depth,t);this.add(e),this._roots.push(e)}const e=this._roots[t];e.depth=this.depth,e.mesh=this.mesh,e.displayParents=this.displayParents,e.displayEdges=this.displayEdges,e.material=this.displayEdges?this.edgeMaterial:this.meshMaterial,e.update()}}updateMatrixWorld(...t){this.position.copy(this.mesh.position),this.rotation.copy(this.mesh.rotation),this.scale.copy(this.mesh.scale),super.updateMatrixWorld(...t)}copy(t){this.depth=t.depth,this.mesh=t.mesh}clone(){return new kt(this.mesh,this.depth)}dispose(){this.edgeMaterial.dispose(),this.meshMaterial.dispose();const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].geometry.dispose()}}const Rt=new r.Box3,Ht=new r.Box3,Ct=new r.Vector3;function Ot(t){switch(typeof t){case"number":return 8;case"string":return 2*t.length;case"boolean":return 4;default:return 0}}function Lt(t){return t._roots.map(((e,n)=>function(t,e){const n={nodeCount:0,leafNodeCount:0,depth:{min:1/0,max:-1/0},tris:{min:1/0,max:-1/0},splits:[0,0,0],surfaceAreaScore:0};return t.traverse(((t,e,r,o,i)=>{const s=r[3]-r[0],a=r[4]-r[1],c=r[5]-r[2],u=2*(s*a+a*c+c*s);n.nodeCount++,e?(n.leafNodeCount++,n.depth.min=Math.min(t,n.depth.min),n.depth.max=Math.max(t,n.depth.max),n.tris.min=Math.min(i,n.tris.min),n.tris.max=Math.max(i,n.tris.max),n.surfaceAreaScore+=u*l*i):(n.splits[o]++,n.surfaceAreaScore+=1*u)}),e),n.tris.min===1/0&&(n.tris.min=0,n.tris.max=0),n.depth.min===1/0&&(n.depth.min=0,n.depth.max=0),n}(t,n)))}function qt(t){const e=new Set,n=[t];let r=0;for(;n.length;){const t=n.pop();if(!e.has(t)){e.add(t);for(let e in t){if(!t.hasOwnProperty(e))continue;r+=Ot(e);const o=t[e];!o||"object"!=typeof o&&"function"!=typeof o?r+=Ot(o):/(Uint|Int|Float)(8|16|32)Array/.test(o.constructor.name)||o instanceof ArrayBuffer?r+=o.byteLength:n.push(o)}}}return r}function Wt(t){const e=t.geometry,n=[],r=e.index,o=e.getAttribute("position");let i=!0;return t.traverse(((t,e,s,a,c)=>{const u={depth:t,isLeaf:e,boundingData:s,offset:a,count:c};n[t]=u,y(0,s,Rt);const l=n[t-1];if(e)for(let t=3*a,e=3*(a+c);t<e;t+=3){const e=r.getX(t),n=r.getX(t+1),s=r.getX(t+2);let a;Ct.fromBufferAttribute(o,e),a=Rt.containsPoint(Ct),Ct.fromBufferAttribute(o,n),a=a&&Rt.containsPoint(Ct),Ct.fromBufferAttribute(o,s),a=a&&Rt.containsPoint(Ct),console.assert(a,"Leaf bounds does not fully contain triangle."),i=i&&a}if(l){y(0,s,Ht);const t=Ht.containsBox(Rt);console.assert(t,"Parent bounds does not fully contain child."),i=i&&t}})),i}function Xt(t){const e=[];return t.traverse(((t,n,o,i,s)=>{const a={bounds:y(0,o,new r.Box3)};n?(a.count=s,a.offset=i):(a.left=null,a.right=null),e[t]=a;const c=e[t-1];c&&(null===c.left?c.left=a:c.right=a)})),e[0]}const Yt=new r.Ray,jt=new r.Matrix4,Zt=r.Mesh.prototype.raycast;function $t(t,e){if(this.geometry.boundsTree){if(void 0===this.material)return;jt.copy(this.matrixWorld).invert(),Yt.copy(t.ray).applyMatrix4(jt);const n=this.geometry.boundsTree;if(!0===t.firstHitOnly){const r=R(n.raycastFirst(Yt,this.material),this,t);r&&e.push(r)}else{const r=n.raycast(Yt,this.material);for(let n=0,o=r.length;n<o;n++){const o=R(r[n],this,t);o&&e.push(o)}}}else Zt.call(this,t,e)}function Jt(t){return this.boundsTree=new Ft(this,t),this.boundsTree}function Kt(){this.boundsTree=null}function Qt(t){switch(t){case 1:return r.RedIntegerFormat;case 2:return r.RGIntegerFormat;case 3:case 4:return r.RGBAIntegerFormat}}class te extends r.DataTexture{constructor(){super(),this.minFilter=r.NearestFilter,this.magFilter=r.NearestFilter,this.generateMipmaps=!1,this.overrideItemSize=null,this._forcedType=null}updateFrom(t){const e=this.overrideItemSize,n=t.itemSize,o=t.count;if(null!==e){if(n*o%e!=0)throw new Error("VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.");t.itemSize=e,t.count=o*n/e}const i=t.itemSize,s=t.count,a=t.normalized,c=t.array.constructor,u=c.BYTES_PER_ELEMENT;let l,d,f,h,p=this._forcedType,y=i;if(null===p)switch(c){case Float32Array:p=r.FloatType;break;case Uint8Array:case Uint16Array:case Uint32Array:p=r.UnsignedIntType;break;case Int8Array:case Int16Array:case Int32Array:p=r.IntType}let m=function(t){switch(t){case 1:return"R";case 2:return"RG";case 3:case 4:return"RGBA"}throw new Error}(i);switch(p){case r.FloatType:f=1,d=function(t){switch(t){case 1:return r.RedFormat;case 2:return r.RGFormat;case 3:case 4:return r.RGBAFormat}}(i),a&&1===u?(h=c,m+="8",c===Uint8Array?l=r.UnsignedByteType:(l=r.ByteType,m+="_SNORM")):(h=Float32Array,m+="32F",l=r.FloatType);break;case r.IntType:m+=8*u+"I",f=a?Math.pow(2,8*c.BYTES_PER_ELEMENT-1):1,d=Qt(i),1===u?(h=Int8Array,l=r.ByteType):2===u?(h=Int16Array,l=r.ShortType):(h=Int32Array,l=r.IntType);break;case r.UnsignedIntType:m+=8*u+"UI",f=a?Math.pow(2,8*c.BYTES_PER_ELEMENT-1):1,d=Qt(i),1===u?(h=Uint8Array,l=r.UnsignedByteType):2===u?(h=Uint16Array,l=r.UnsignedShortType):(h=Uint32Array,l=r.UnsignedIntType)}3!==y||d!==r.RGBAFormat&&d!==r.RGBAIntegerFormat||(y=4);const g=Math.ceil(Math.sqrt(s)),x=new h(y*g*g);for(let e=0;e<s;e++){const n=y*e;x[n]=t.getX(e)/f,i>=2&&(x[n+1]=t.getY(e)/f),i>=3&&(x[n+2]=t.getZ(e)/f,4===y&&(x[n+3]=1)),i>=4&&(x[n+3]=t.getW(e)/f)}this.internalFormat=m,this.format=d,this.type=l,this.image.width=g,this.image.height=g,this.image.data=x,this.needsUpdate=!0,this.dispose(),t.itemSize=n,t.count=o}}class ee extends te{constructor(){super(),this._forcedType=r.UnsignedIntType}}class ne extends te{constructor(){super(),this._forcedType=r.IntType}}class re extends te{constructor(){super(),this._forcedType=r.FloatType}}class oe{constructor(){this.autoDispose=!0,this.index=new ee,this.position=new re,this.bvhBounds=new r.DataTexture,this.bvhContents=new r.DataTexture,this.index.overrideItemSize=3}updateFrom(t){const{geometry:e}=t;!function(t,e,n){const o=t._roots;if(1!==o.length)throw new Error("MeshBVHUniformStruct: Multi-root BVHs not supported.");const i=o[0],s=new Uint16Array(i),a=new Uint32Array(i),c=new Float32Array(i),u=i.byteLength/d,l=2*Math.ceil(Math.sqrt(u/2)),f=new Float32Array(4*l*l),h=Math.ceil(Math.sqrt(u)),p=new Uint32Array(2*h*h);for(let t=0;t<u;t++){const e=t*d/4,n=2*e,r=e;for(let e=0;e<3;e++)f[8*t+0+e]=c[r+0+e],f[8*t+4+e]=c[r+3+e];if($(n,s)){const r=K(n,s),o=J(e,a),i=4294901760|r;p[2*t+0]=i,p[2*t+1]=o}else{const n=4*tt(e,a)/d,r=et(e,a);p[2*t+0]=r,p[2*t+1]=n}}e.image.data=f,e.image.width=l,e.image.height=l,e.format=r.RGBAFormat,e.type=r.FloatType,e.internalFormat="RGBA32F",e.minFilter=r.NearestFilter,e.magFilter=r.NearestFilter,e.generateMipmaps=!1,e.needsUpdate=!0,e.dispose(),n.image.data=p,n.image.width=h,n.image.height=h,n.format=r.RGIntegerFormat,n.type=r.UnsignedIntType,n.internalFormat="RG32UI",n.minFilter=r.NearestFilter,n.magFilter=r.NearestFilter,n.generateMipmaps=!1,n.needsUpdate=!0,n.dispose()}(t,this.bvhBounds,this.bvhContents),this.index.updateFrom(e.index),this.position.updateFrom(e.attributes.position)}dispose(){const{index:t,position:e,bvhBounds:n,bvhContents:r}=this;t&&t.dispose(),e&&e.dispose(),n&&n.dispose(),r&&r.dispose()}}const ie="\n#ifndef TRI_INTERSECT_EPSILON\n#define TRI_INTERSECT_EPSILON 1e-5\n#endif\n\n#ifndef INFINITY\n#define INFINITY 1e20\n#endif\n\nstruct BVH {\n\n\tusampler2D index;\n\tsampler2D position;\n\n\tsampler2D bvhBounds;\n\tusampler2D bvhContents;\n\n};\n\n// Note that a struct cannot be used for the hit record including faceIndices, faceNormal, barycoord,\n// side, and dist because on some mobile GPUS (such as Adreno) numbers are afforded less precision specifically\n// when in a struct leading to inaccurate hit results. See KhronosGroup/WebGL#3351 for more details.\n",se="\n\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\n\n\treturn\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\n\n}\n\nvoid ndcToCameraRay(\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\n\tout vec3 rayOrigin, out vec3 rayDirection\n) {\n\n\t// get camera look direction and near plane for camera clipping\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\n\tfloat near = abs( nearVector.z / nearVector.w );\n\n\t// get the camera direction and position from camera matrices\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\n\tdirection /= direction.w;\n\tdirection = cameraWorld * direction - origin;\n\n\t// slide the origin along the ray until it sits at the near clip plane position\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\n\n\trayOrigin = origin.xyz;\n\trayDirection = direction.xyz;\n\n}\n\nfloat intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax ) {\n\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t// https://tavianator.com/2011/ray_box.html\n\tvec3 invDir = 1.0 / rayDirection;\n\n\t// find intersection distances for each plane\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t// get the min and max distances from each intersection\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t// get the furthest hit distance\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\tfloat t0 = max( t.x, t.y );\n\n\t// get the minimum hit distance\n\tt = min( tMaxHit.xx, tMaxHit.yz );\n\tfloat t1 = min( t.x, t.y );\n\n\t// set distance to 0.0 if the ray starts inside the box\n\tfloat dist = max( t0, 0.0 );\n\n\treturn t1 >= dist ? dist : INFINITY;\n\n}\n\nbool intersectsTriangle(\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n) {\n\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\tvec3 edge1 = b - a;\n\tvec3 edge2 = c - a;\n\tnorm = cross( edge1, edge2 );\n\n\tfloat det = - dot( rayDirection, norm );\n\tfloat invdet = 1.0 / det;\n\n\tvec3 AO = rayOrigin - a;\n\tvec3 DAO = cross( AO, rayDirection );\n\n\tvec4 uvt;\n\tuvt.x = dot( edge2, DAO ) * invdet;\n\tuvt.y = - dot( edge1, DAO ) * invdet;\n\tuvt.z = dot( AO, norm ) * invdet;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// set the hit information\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\tdist = uvt.z;\n\tside = sign( det );\n\tnorm = side * normalize( norm );\n\n\t// add an epsilon to avoid misses between triangles\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n}\n\nbool intersectTriangles(\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection, uint offset, uint count,\n\tinout float minDistance,\n\n\t// output variables\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\n\tout float side, out float dist\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord, localNormal;\n\tfloat localDist, localSide;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( bvh.index, i ).xyz;\n\t\tvec3 a = texelFetch1D( bvh.position, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( bvh.position, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( bvh.position, indices.z ).rgb;\n\n\t\tif (\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t&& localDist < minDistance\n\t\t) {\n\n\t\t\tfound = true;\n\t\t\tminDistance = localDist;\n\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = localNormal;\n\n\t\t\tside = localSide;\n\t\t\tbarycoord = localBarycoord;\n\t\t\tdist = localDist;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\nfloat intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, BVH bvh, uint currNodeIndex ) {\n\n\tvec3 boundsMin = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 0u ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 1u ).xyz;\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax );\n\n}\n\nbool bvhIntersectFirstHit(\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection,\n\n\t// output variables\n\tout uvec4 faceIndices, out vec3 faceNormal, out vec3 barycoord,\n\tout float side, out float dist\n) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ 60 ];\n\tstack[ 0 ] = 0u;\n\n\tfloat triangleDistance = 1e20;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < 60 ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh, currNodeIndex );\n\t\tif ( boundsHitDistance == INFINITY || boundsHitDistance > triangleDistance ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh.bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\n\t\t\tfound = intersectTriangles(\n\t\t\t\tbvh, rayOrigin, rayDirection, offset, count, triangleDistance,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t) || found;\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\n",ae=new r.Vector3,ce=new r.Vector3,ue=new r.Vector3,le=new r.Vector4,de=new r.Vector3,fe=new r.Vector3,he=new r.Vector4,pe=new r.Vector4,ye=new r.Matrix4,me=new r.Matrix4;function ge(t,e){if(!t&&!e)return;const n=t.count===e.count,r=t.normalized===e.normalized,o=t.array.constructor===e.array.constructor,i=t.itemSize===e.itemSize;if(!(n&&r&&o&&i))throw new Error}function xe(t,e=null){const n=t.array.constructor,o=t.normalized,i=t.itemSize,s=null===e?t.count:e;return new r.BufferAttribute(new n(i*s),i,o)}function be(t,e,n=0){if(t.isInterleavedBufferAttribute){const r=t.itemSize;for(let o=0,i=t.count;o<i;o++){const i=o+n;e.setX(i,t.getX(o)),r>=2&&e.setY(i,t.getY(o)),r>=3&&e.setZ(i,t.getZ(o)),r>=4&&e.setW(i,t.getW(o))}}else{const r=e.array,o=r.constructor,i=r.BYTES_PER_ELEMENT*t.itemSize*n;new o(r.buffer,i,t.array.length).set(t.array)}}function we(t,e,n){const r=t.elements,o=e.elements;for(let t=0,e=o.length;t<e;t++)r[t]+=o[t]*n}function ve(t,e,n){const r=t.skeleton,o=t.geometry,i=r.bones,s=r.boneInverses;he.fromBufferAttribute(o.attributes.skinIndex,e),pe.fromBufferAttribute(o.attributes.skinWeight,e),ye.elements.fill(0);for(let t=0;t<4;t++){const e=pe.getComponent(t);if(0!==e){const n=he.getComponent(t);me.multiplyMatrices(i[n].matrixWorld,s[n]),we(ye,me,e)}}return ye.multiply(t.bindMatrix).premultiply(t.bindMatrixInverse),n.transformDirection(ye),n}function Be(t,e,n,r,o){de.set(0,0,0);for(let i=0,s=t.length;i<s;i++){const s=e[i],a=t[i];0!==s&&(fe.fromBufferAttribute(a,r),n?de.addScaledVector(fe,s):de.addScaledVector(fe.sub(o),s))}o.add(de)}class Te{constructor(t){Array.isArray(t)||(t=[t]);const e=[];t.forEach((t=>{t.traverse((t=>{t.isMesh&&e.push(t)}))})),this.meshes=e,this.useGroups=!0,this.applyWorldTransforms=!0,this.attributes=["position","normal","tangent","uv","uv2"],this._intermediateGeometry=new Array(e.length).fill().map((()=>new r.BufferGeometry))}getMaterials(){const t=[];return this.meshes.forEach((e=>{Array.isArray(e.material)?t.push(...e.material):t.push(e.material)})),t}generate(t=new r.BufferGeometry){const{meshes:e,useGroups:n,_intermediateGeometry:o}=this;for(let t=0,n=e.length;t<n;t++){const n=e[t],r=o[t];this._convertToStaticGeometry(n,r)}!function(t,e={useGroups:!1,updateIndex:!1},n=new r.BufferGeometry){const o=null!==t[0].index,{useGroups:i,updateIndex:s}=e,a=new Set(Object.keys(t[0].attributes)),c={};let u=0;for(let e=0;e<t.length;++e){const r=t[e];let s=0;if(o!==(null!==r.index))throw new Error("StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");for(const t in r.attributes){if(!a.has(t))throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure "'+t+'" attribute exists among all geometries, or in none of them.');void 0===c[t]&&(c[t]=[]),c[t].push(r.attributes[t]),s++}if(s!==a.size)throw new Error("StaticGeometryGenerator: Make sure all geometries have the same number of attributes.");if(i){let t;if(o)t=r.index.count;else{if(void 0===r.attributes.position)throw new Error("StaticGeometryGenerator: The geometry must have either an index or a position attribute");t=r.attributes.position.count}n.addGroup(u,t,e),u+=t}}if(o){let e=!1;if(!n.index){let o=0;for(let e=0;e<t.length;++e)o+=t[e].index.count;n.setIndex(new r.BufferAttribute(new Uint32Array(o),1,!1)),e=!0}if(s||e){const e=n.index;let r=0,o=0;for(let n=0;n<t.length;++n){const i=t[n],s=i.index;for(let t=0;t<s.count;++t)e.setX(r,s.getX(t)+o),r++;o+=i.attributes.position.count}}}for(const t in c){const e=c[t];if(!(t in n.attributes)){let r=0;for(const t in e)r+=e[t].count;n.setAttribute(t,xe(c[t][0],r))}const r=n.attributes[t];let o=0;for(const t in e){const n=e[t];be(n,r,o),o+=n.count}}}(o,{useGroups:n},t);for(const e in t.attributes)t.attributes[e].needsUpdate=!0;return t}_convertToStaticGeometry(t,e=new r.BufferGeometry){const n=t.geometry,o=this.applyWorldTransforms,i=this.attributes.includes("normal"),s=this.attributes.includes("tangent"),a=n.attributes,c=e.attributes;e.index||(e.index=n.index),c.position||e.setAttribute("position",xe(a.position)),i&&!c.normal&&a.normal&&e.setAttribute("normal",xe(a.normal)),s&&!c.tangent&&a.tangent&&e.setAttribute("tangent",xe(a.tangent)),ge(n.index,e.index),ge(a.position,c.position),i&&ge(a.normal,c.normal),s&&ge(a.tangent,c.tangent);const u=a.position,l=i?a.normal:null,d=s?a.tangent:null,f=n.morphAttributes.position,h=n.morphAttributes.normal,p=n.morphAttributes.tangent,y=n.morphTargetsRelative,m=t.morphTargetInfluences,g=new r.Matrix3;g.getNormalMatrix(t.matrixWorld);for(let e=0,n=a.position.count;e<n;e++)ae.fromBufferAttribute(u,e),l&&ce.fromBufferAttribute(l,e),d&&(le.fromBufferAttribute(d,e),ue.fromBufferAttribute(d,e)),m&&(f&&Be(f,m,y,e,ae),h&&Be(h,m,y,e,ce),p&&Be(p,m,y,e,ue)),t.isSkinnedMesh&&(t.boneTransform(e,ae),l&&ve(t,e,ce),d&&ve(t,e,ue)),o&&ae.applyMatrix4(t.matrixWorld),c.position.setXYZ(e,ae.x,ae.y,ae.z),l&&(o&&ce.applyNormalMatrix(g),c.normal.setXYZ(e,ce.x,ce.y,ce.z)),d&&(o&&ue.transformDirection(t.matrixWorld),c.tangent.setXYZW(e,ue.x,ue.y,ue.z,le.w));for(const t in this.attributes){const n=this.attributes[t];"position"!==n&&"tangent"!==n&&"normal"!==n&&n in a&&(c[n]||e.setAttribute(n,xe(a[n])),ge(a[n],c[n]),be(a[n],c[n]))}return e}}}}]);